//! [snippet1]
// We include what we need for the test
#include <gatb/gatb_core.hpp>

using namespace std;

/********************************************************************************/
/*                       Solid partitions statistics                            */
/*                                                                              */
/* This snippet computes statistics about the solid kmers of each partition     */
/* generated by the sorting count algorithm.                                    */
/*                                                                              */
/********************************************************************************/
int main (int argc, char* argv[])
{
    // We create a command line parser.
    OptionsParser parser ("SortingCount");
    parser.push_back (new OptionOneParam (STR_URI_INPUT,  "sorting count input", true));
    parser.push_back (new OptionOneParam (STR_URI_OUTPUT, "distrib output",      false));
    parser.push_back (new OptionOneParam (STR_NB_CORES,   "number of cores",     false, "0"));

    try
    {
        // Shortcuts.
        typedef Kmer<>::Count           Count;
        typedef Kmer<>::Type            Type;
        typedef Kmer<>::ModelCanonical              ModelCanon;
        typedef Kmer<>::ModelMinimizer<ModelCanon>  Model;

        // We parse the user options.
        IProperties* options = parser.parse (argc, argv);

        // We load the object storing the couples [kmer,abundance]
        Storage* storage = StorageFactory(STORAGE_HDF5).load (options->getStr(STR_URI_INPUT));   LOCAL (storage);

        // We get the group inside the storage object
        Group& dskGroup = storage->getGroup("dsk");

        // We retrieve the partition holding the couples [kmer,abundance]
        Partition<Count>& solidKmers = dskGroup.getPartition<Count> ("solid");

        // We retrieve the repartitor hash function
        Repartitor repart;
        repart.load (dskGroup);

        // We get the kmer size
        size_t kmerSize = atol (storage->root().getProperty("kmer_size").c_str());

        // We get a minimizer model
        Model model (kmerSize, 8);

        // We create the output file
        string outputUri = options->get(STR_URI_OUTPUT) ?
            options->getStr(STR_URI_OUTPUT) :
            System::file().getBaseName(options->getStr(STR_URI_INPUT)) + ".distrib";

        FILE* outputFile = fopen (outputUri.c_str(), "w");
        if (outputFile == 0)  { throw Exception ("unable to open output file"); }

        // A little bit of parallelization won't hurt
        Dispatcher dispatcher (options->getInt(STR_NB_CORES));

        Range<size_t> range(0, solidKmers.size()-1);

        // we read the couples [kmer,abundance] with an iterator over each collection of the partition
        ProgressIterator<size_t> itPart (range);
        for (itPart.first(); !itPart.isDone(); itPart.next())
        {
            // Shortcut
            size_t currentPart = itPart.item();

            ThreadObject<size_t> nbIn  = 0;
            ThreadObject<size_t> nbOut = 0;

            // We iterate the current collection inside the partition
            dispatcher.iterate (solidKmers[currentPart].iterator(),  [&]  (const Count& count)
            {
                size_t& localIn  = nbIn();
                size_t& localOut = nbOut();

                // We iterate the neighbors of the current kmer
                model.iterateNeighbors (count.value, [&] (const Type& neighbor)
                {
                    // We look whether the neighbor is in the same partition as the current one
                    if ( repart(model.getMinimizerValue(neighbor)) == currentPart ) {  localIn++;   }
                    else                                                            {  localOut++;  }
                });
            });

            nbIn. foreach ([&] (int localSum)  {  *nbIn  += localSum;  });
            nbOut.foreach ([&] (int localSum)  {  *nbOut += localSum;  });

            fprintf (outputFile, "%ld  %ld  %ld  %ld  %.3f\n",
                currentPart , *nbIn, *nbOut, (*nbIn+*nbOut), 100.0 * (double)*nbIn / (double)(*nbIn+*nbOut)
            );
        }

        fclose (outputFile);
    }
    catch (OptionFailure& e)
    {
        return e.displayErrors (std::cout);
    }
    catch (Exception& e)
    {
        std::cerr << "EXCEPTION: " << e.getMessage() << std::endl;
    }

    return EXIT_SUCCESS;
}
//! [snippet1]
