#include <assert.h>
#include <bcalm_1.hpp>
#include <glue.hpp>
#include <ograph.h>
#include <iostream>
#include <memory>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <chrono>
#include <tuple>
#include "binSeq.h"

//#define BINSEQ // "graph4 is not ready" according to antoine. also, initBinSeq provokes segfault at end of bcalm

#define OSX 1
#ifndef OSX
#include <sys/sysinfo.h> // to determine system memory
#endif

const size_t SPAN = KMER_SPAN(1); // todo: adapt span using Minia's technique

/** Shortcuts. */
size_t kmerSize=31;
size_t minSize=8;
size_t nb_threads=1;
size_t nb_threads_simulate=1; // this is somewhat a legacy parameter, i should get rid of (and replace by nb_threads)


/********************************************************************************/


bcalm_1::bcalm_1 ()  : Tool ("bcalm_1"){
    // compareKmers("out.fa","chr14-k55-t5.kmer");
    // cout<<reversecompletment("ATATATATATCCTATATATATATGCCCTATATATATATCCTATATATATATGCC");
	getParser()->push_back (new OptionOneParam ("-in", "input file",  true));
	getParser()->push_back (new OptionOneParam ("-out", "output prefix",  false, "unitigs"));
	getParser()->push_back (new OptionOneParam ("-k", "kmer size",  false,"31"));
	getParser()->push_back (new OptionOneParam ("-m", "minimizer size",  false,"8"));
	getParser()->push_back (new OptionOneParam ("-abundance", "abundance threshold",  false,"1"));
	getParser()->push_back (new OptionOneParam ("-minimizer-type", "use lexicographical minimizers (0) or frequency based (1)",  false,"1"));
	getParser()->push_back (new OptionOneParam ("-dsk-memory", "max memory for kmer counting (MB)", false, "1500"));
	getParser()->push_back (new OptionOneParam ("-dsk-disk", "max disk space for kmer counting (MB)", false, "default"));
}

void bcalm_1::execute (){
    string inputFile(getInput()->getStr("-in"));
    kmerSize=getInput()->getInt("-k");
    size_t abundance=getInput()->getInt("-abundance");
    minSize=getInput()->getInt("-m");
    nb_threads = getInput()->getInt("-nb-cores");
    // nb_threads=1;
    int minimizer_type = getInput()->getInt("-minimizer-type");
    bool verbose = (getInput()->get(STR_VERBOSE) && getInput()->getInt(STR_VERBOSE) > 0);
    string prefix = getInput()->getStr("-out");
    
    BankFasta out (prefix + ".fa");
    int dsk_memory = getInput()->getInt("-dsk-memory");
    string dsk_disk = (getInput()->getStr("-dsk-disk").compare("default") != 0) ? ("-max-disk " + getInput()->getStr("-dsk-disk")) : "";

        if (nb_threads > nb_threads_simulate)
        nb_threads_simulate = nb_threads;

    /** check if it's a tiny memory machine, e.g. ec2 micro, if so, limit memory during kmer counting (default is 1.5G) */
#ifndef OSX
    struct sysinfo info;
    sysinfo(&info);
    int total_ram = (int)(((double)info.totalram*(double)info.mem_unit)/1024/1024);
    cout << "\nTotal RAM: " << total_ram << " MB\n";
#else
    int total_ram = 4000; /* don't know how to estimate total ram in osx; maybe GATB knows actually, so todo, use it*/
#endif
    if (total_ram < 1500)
        dsk_memory = 500;

    string input_prefix = inputFile.substr(0,inputFile.size()-3);
    bool is_kmercounted = inputFile.substr(inputFile.size()-2,2) == "h5";
    if ((input_prefix.compare("unitigs") != 0) && prefix.compare("unitigs") == 0 && is_kmercounted)
    {
        prefix = input_prefix;
        //cout<< "-out is 'unitigs' (default) and input is kmercounted (and not 'unitigs'): setting output to "<< prefix << endl;
    }

    /** kmer counting **/
    bool did_kmercounting = false;
    auto start_kc=chrono::system_clock::now();
    {   /**DO NOT REMOVE THOSE BRACKETS**/

        if (!is_kmercounted)
        {
            Graph graph = Graph::create ("-in %s -kmer-size %d -minimizer-size %d -mphf none -bloom none -out %s.h5  -abundance-min %d -verbose 1 -minimizer-type %d -repartition-type 1 -max-memory %d %s", inputFile.c_str(), kmerSize, minSize, prefix.c_str(), abundance, minimizer_type, dsk_memory, dsk_disk.c_str());

            did_kmercounting = true;
        }
    }

    auto end_kc=chrono::system_clock::now();
    auto waitedFor_kc=end_kc-start_kc;
    double unit = 1000000000;
    cout.setf(ios_base::fixed);
    cout.precision(1);

    if (did_kmercounting)
    {
        cout<<"Kmer-counting wallclock: "<<chrono::duration_cast<chrono::nanoseconds>(waitedFor_kc).count() / unit <<" secs"<< endl;
        memory_usage("post-kmer counting");
    }
    
    Storage* storage = StorageFactory(STORAGE_HDF5).load ( prefix + ".h5");


    bcalm2(storage, prefix, kmerSize, abundance, minSize, nb_threads, minimizer_type, verbose);
}



